name: Build, Deploy and Test to Recette Environment

on:
  workflow_dispatch:
  push:
    branches: [dev]

env:
  RECETTE_IP: "34.22.137.184"
  IMAGE_NAME: elgg-app
  K8S_NAMESPACE: recette
  DEPLOYMENT_TIMEOUT: 300s

jobs:
  docker-build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    outputs:
      full-image-tag: ${{ steps.output.outputs.image-tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate image tags
        id: tags
        run: |
          TIMESTAMP=$(date +%Y%m%d)
          SHORT_SHA=$(git rev-parse --short HEAD)
          IMAGE_BASE="${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}"
          
          TIMESTAMPED_TAG="${IMAGE_BASE}:recette-${TIMESTAMP}-${SHORT_SHA}"
          LATEST_TAG="${IMAGE_BASE}:recette-latest"
          
          echo "timestamped-tag=${TIMESTAMPED_TAG}" >> $GITHUB_OUTPUT
          echo "latest-tag=${LATEST_TAG}" >> $GITHUB_OUTPUT
          echo "primary-tag=${TIMESTAMPED_TAG}" >> $GITHUB_OUTPUT
          
          echo "Generated tags:"
          echo "- ${TIMESTAMPED_TAG}"
          echo "- ${LATEST_TAG}"

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        id: build_and_push
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: |
            ${{ steps.tags.outputs.timestamped-tag }}
            ${{ steps.tags.outputs.latest-tag }}
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          cache-to: type=inline

      - name: Set output
        id: output
        run: |
          echo "image-tag=${{ steps.tags.outputs.primary-tag }}" >> $GITHUB_OUTPUT
          echo "âœ… Build job output set to: ${{ steps.tags.outputs.primary-tag }}"

  deploy:
    name: Deploy to Recette Environment
    needs: docker-build
    outputs:
      image-tag: ${{ needs.docker-build.outputs.full-image-tag }}
    permissions:
      contents: read
      deployments: write
    environment:
      name: recette
      url: http://${{ env.RECETTE_IP }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GKE_SA_KEY }}

      - name: Set up gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GKE_PROJECT }}
          install_kubectl: true

      - name: Configure GKE Auth
        run: |
          gcloud components install gke-gcloud-auth-plugin -q
          gcloud config set container/use_application_default_credentials true

      - name: Connect to GKE Cluster
        run: |
          gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER }} \
            --region ${{ secrets.GKE_REGION }} \
            --project ${{ secrets.GKE_PROJECT }}

      - name: Debug Image Tag
        run: |
          echo "Deploying image: ${{ needs.docker-build.outputs.full-image-tag }}"

      - name: Verify Image Exists
        run: |
          # Debug: Show what image we're trying to pull
          echo "Image to deploy: ${{ needs.docker-build.outputs.full-image-tag }}"
          
          # Verify image tag is not empty
          if [ -z "${{ needs.docker-build.outputs.full-image-tag }}" ]; then
            echo "::error::Image tag is empty!"
            exit 1
          fi
          
          # Use crane to verify image exists (crane is pre-installed in GitHub runners)
          curl -sL "https://github.com/google/go-containerregistry/releases/latest/download/go-containerregistry_Linux_x86_64.tar.gz" | tar -xz crane
          sudo mv crane /usr/local/bin/
          
          # Login to Docker Hub using crane
          echo "${{ secrets.DOCKERHUB_TOKEN }}" | crane auth login docker.io -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
          
          # Verify image exists
          crane manifest ${{ needs.docker-build.outputs.full-image-tag }} > /dev/null || \
            { echo "::error::Image not found in registry: ${{ needs.docker-build.outputs.full-image-tag }}"; exit 1; }
          
          echo "âœ… Image verification successful"

      - name: Deploy Application Stack
        run: |
          # Apply Kubernetes manifests
          kubectl apply -f k8s/ -n ${{ env.K8S_NAMESPACE }}

          # Update image if deployment exists
          if kubectl get deployment elgg-app -n ${{ env.K8S_NAMESPACE }} >/dev/null 2>&1; then
            kubectl set image deployment/elgg-app \
              elgg-app=${{ needs.docker-build.outputs.full-image-tag }} \
              -n ${{ env.K8S_NAMESPACE }}
          fi

          # Verify deployments
          kubectl rollout status deployment/elgg-app \
            -n ${{ env.K8S_NAMESPACE }} \
            --timeout=${{ env.DEPLOYMENT_TIMEOUT }} || \
            { kubectl describe deployment elgg-app -n ${{ env.K8S_NAMESPACE }}; exit 1; }

          kubectl rollout status deployment/elgg-phpmyadmin \
            -n ${{ env.K8S_NAMESPACE }} \
            --timeout=${{ env.DEPLOYMENT_TIMEOUT }}

          # Display deployment status
          kubectl get svc,deploy,pods -n ${{ env.K8S_NAMESPACE }}
          kubectl get events -n ${{ env.K8S_NAMESPACE }} --sort-by='.lastTimestamp'

      - name: Rollback if deployment failed
        if: failure()
        run: |
          echo "::warning::Deployment failed, attempting rollback"
          kubectl rollout undo deployment/elgg-app -n ${{ env.K8S_NAMESPACE }}
          kubectl rollout status deployment/elgg-app -n ${{ env.K8S_NAMESPACE }} --timeout=60s
          echo "Rollback completed for elgg-app deployment"

  security-scan:
    name: Security Scan with ZAP
    needs: deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
    steps:
      - name: Run OWASP ZAP Scan
        uses: zaproxy/action-full-scan@v0.12.0
        with:
          target: 'http://${{ env.RECETTE_IP }}'
          rules_file_name: '.zap/recette-rules.tsv'
          cmd_options: '-a -T 60'
          report_html: true
          report_md: true

      - name: Upload Scan Reports
        uses: actions/upload-artifact@v3
        with:
          name: security-scan-reports
          path: |
            zap-report.html
            zap-report.md

  quality-gate:
    name: Quality Approval Gate
    needs: security-scan
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      issues: read
    steps:
      - name: Get PR Information
        id: pr-info
        uses: octokit/graphql-action@v2.x
        with:
          query: |
            query($owner:String!, $repo:String!, $prNumber:Int!) {
              repository(owner:$owner, name:$repo) {
                pullRequest(number:$prNumber) {
                  headRefOid
                  title
                }
              }
            }
          owner: ${{ github.repository_owner }}
          repo: ${{ github.event.repository.name }}
          prNumber: ${{ github.event.pull_request.number }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Deployment Notification
        uses: actions/github-script@v6
        with:
          script: |
            const commitHash = '${{ steps.pr-info.outputs.data.repository.pullRequest.headRefOid }}'.substring(0, 7);
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'ðŸš€ UAT Deployment Ready for Review\n\n' +
                    '**Application Details:**\n' +
                    '```yaml\n' +
                    `image: ${{ needs.deploy.outputs.image-tag }}\n` +
                    `environment: http://${{ env.RECETTE_IP }}\n` +
                    `commit: ${commitHash}\n` +
                    '```\n\n' +
                    '**Security Scan:** [View Report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})\n\n' +
                    'To approve this deployment, comment with:\n' +
                    '`/approve-recette`'
            })
