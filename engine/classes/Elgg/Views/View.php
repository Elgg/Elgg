<?php
namespace Elgg\Views;

use Elgg\Structs\Map;
use Elgg\Filesystem\File;
use Elgg\DeprecationWrapper;

/**
 * A service for rendering, inspecting, and configuring a single view.
 * 
 * @since 2.0.0
 * @access private
 */
class View {
	/** @var string */
	private $name;
	
	/** @var bool */
	private $is_cacheable = false;
	
	/** @var View[] */
	private $prepends = array();
	
	/** @var View[] */
	private $appends = array();
	
	/** @var Map<Viewtype,?File> */
	private $paths;
	
	/**
	 * Constructor
	 * 
	 * @param string              $name  The name of the view
	 * @param Map<Viewtype,?File> $paths The paths that define this view
	 */
	public function __construct($name, Map/*<Viewtype,?File>*/ $paths) {
		$this->name = $name;
		$this->paths = $paths;
	}
	
	/**
	 * Returns the name of this view.
	 * 
	 * @return string
	 */
	public function getName() {
		return $this->name;
	}

	/**
	 * Indicates whether the view has been registered/extended.
	 * 
	 * @param Viewtype $viewtype The output format
	 * @param boolean  $recurse  Whether to check for extensions too.
	 * 
	 * @return boolean
	 */
	public function exists(Viewtype $viewtype, $recurse = true) {
		$location = $this->paths->get($viewtype);

		if (!empty($location)) {
			return true;
		}

		// If we got here then check whether this exists as an extension
		if ($recurse) {
			$extensions = array_merge($this->prepends, $this->appends);
			/* @var View[] $extensions */

			foreach ($extensions as $extension) {
				// do not recursively check to stay away from infinite loops
				if ($extension->exists($viewtype, false)) {
					return true;
				}
			}
		}

		return false;
	}

	/**
	 * Registers a view extension to be prepended to this view.
	 * 
	 * @param View $extension
	 * @param int  $priority
	 * 
	 * @access private
	 */
	public function prepend(View $extension, $priority) {
		// raise priority until it doesn't match one already registered
		while (isset($this->prepends[$priority])) {
			$priority++;
		}

		$this->prepends[$priority] = $extension;
		
		ksort($this->prepends);
	}
	
	/**
	 * Registers a view extension to be appended to this view.
	 * 
	 * @param View $extension
	 * @param int  $priority
	 * 
	 * @access private
	 */
	public function append(View $extension, $priority) {
		// raise priority until it doesn't match one already registered
		while (isset($this->appends[$priority])) {
			$priority++;
		}

		$this->appends[$priority] = $extension;
		
		ksort($this->appends);
	}

	/**
	 * Removes any previously registered view extension.
	 * 
	 * @param string $extension
	 * 
	 * @return boolean
	 * @access private
	 */
	public function unextend(View $extension = null) {
		$priority = array_search($extension, $this->prepends, true);
		
		if ($priority !== false) {
			unset($this->prepends[$priority]);
			return true;
		}
		
		$priority = array_search($extension, $this->appends, true);
		if ($priority !== false) {
			unset($this->appends[$priority]);
			return true;
		}

		return false;
	}
	
	/**
	 * Generates the output for this view, including any extensions that have
	 * been registered with it.
	 * 
	 * @param array    $vars     Arbitrary args with which to render the view.
	 * @param Viewtype $viewtype The output format.
	 * 
	 * @return string
	 */
	public function render(array $vars, Viewtype $viewtype) {
		$content = '';
		
		foreach ($this->prepends as $extension) {
			$content .= $extension->render($vars, $viewtype);
		}
		
		$content .= $this->renderContent($vars, $viewtype);
		
		foreach ($this->appends as $extension) {
			$content .= $extension->render($vars, $viewtype);
		}
		
		return $content;
	}
	
	/**
	 * Includes view PHP or static file without regard to view extensions.
	 * 
	 * @param array    $vars     Variables passed to view
	 * @param Viewtype $viewtype The viewtype
	 *
	 * @return string output generated by view file inclusion or false
	 */
	private function renderContent(array $vars, Viewtype $viewtype) {
		$location = $this->paths->get($viewtype);

		if (empty($location)) {
			return '';
		}

		/* @var File $location */

		// Can't just check isCacheable here because if it is a cacheable file
		// with a PHP extension we still want to render it with PHP.
		if ($location->getExtension() != 'php') {
			return $location->getContents();
		}
	
		ob_start();
		include $location->getFullPath();
		return ob_get_clean();
	}

	/**
	 * Forces this view to be permanently cacheable
	 * 
	 * @param bool $cacheable Whether this view should be considered cacheable.
	 * 
	 * @return void
	 */
	public function setCacheable($cacheable) {
		$this->is_cacheable = $cacheable;
	}
	
	/**
	 * Indicates whether this view is permanently cacheable.
	 * 
	 * Always returns true for views that use a non-PHP file for rendering,
	 * regardless of the value passed to `setCacheable()`.
	 * 
	 * @return bool 
	 */
	public function isCacheable() {
		if ($this->is_cacheable) {
			return true;
		}

		foreach ($this->paths->values() as $file) {
			if ($file->getExtension() != 'php') {
				// Short-circuit for the next time this method is called.
				$this->setCacheable(true);
				return true;
			}
		}
		
		return false;
	}
}