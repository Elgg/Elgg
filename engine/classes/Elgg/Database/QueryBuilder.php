<?php
/**
 *
 */

namespace Elgg\Database;

use DatabaseException;
use DateTime;
use Doctrine\DBAL\Connection;
use Doctrine\DBAL\Query\Expression\ExpressionBuilder;
use Elgg\Config;

/**
 * DBAL Query Builder
 */
class QueryBuilder extends \Doctrine\DBAL\Query\QueryBuilder {

	const DB_SELECT = 'select';
	const DB_INSERT = 'insert';
	const DB_UPDATE = 'update';
	const DB_DELETE = 'delete';

	const TABLE_METADATA = 'metadata';
	const TABLE_RELATIONSHIPS = 'entity_relationships';

	protected $joins = [];

	protected $from;
	protected $alias;

	/**
	 * Constructs a new SELECT query
	 *
	 * @param string $from  Main table name
	 * @param string $alias Select alias
	 *
	 * @return static
	 *
	 * @throws DatabaseException
	 */
	public static function createSelect($from, $alias = '') {
		$connection = _elgg_services()->db->getConnection('write');
		$qb = new static($connection);
		$qb->from($from, $alias);

		return $qb;
	}

	/**
	 * Creates a new QueryBuilder for join/where subqueries using the DB connection of the primary QueryBuilder
	 *
	 * @param string $table Main table name
	 * @param string $alias Select alias
	 *
	 * @return static
	 */
	public function selectSubquery($table, $alias = '') {
		$qb = new static($this->getConnection());
		$qb->from($table, $alias);

		return $qb;
	}

	/**
	 * Prefixes the table name with installation DB prefix
	 *
	 * @param string $table
	 *
	 * @return string
	 */
	public function prefix($table) {
		$prefix = _elgg_services()->db->prefix;
		if (strpos($table, $prefix) !== 0) {
			return "{$prefix}{$table}";
		}

		return $table;
	}

	/**
	 * Returns the name of the primary table
	 *
	 * @return string
	 */
	public function getFromTable() {
		return $this->from;
	}

	/**
	 * Returns the alias of the primary table
	 * @return string
	 */
	public function getFromAlias() {
		return $this->alias;
	}

	/**
	 * Sets a new parameter assigning it a unique parameter key/name if none provided
	 * Returns the name of the new parameter
	 *
	 * @param mixed  $value Parameter value
	 * @param string $type  Parameter type
	 * @param string $key   Parameter key/index
	 *
	 * @return string
	 */
	public function param($value, $type = null, $key = null) {
		if (!$key) {
			$parameters = $this->getParameters();
			$key = ":qb" . (count($parameters) + 1);
		}

		if (is_array($value)) {
			if ($type === 'integer') {
				$type = Connection::PARAM_INT_ARRAY;
			} else if ($type === 'string') {
				$type = Connection::PARAM_STR_ARRAY;
			}
		}

		$this->setParameter($key, $value, $type);

		return $key;
	}

	/**
	 * {@inheritdoc}
	 */
	public function from($from, $alias = null) {
		$this->from = $from;
		$this->alias = $alias;

		return parent::from($this->prefix($from), $alias);
	}

	/**
	 * {@inheritdoc}
	 */
	public function join($fromAlias, $join, $alias, $condition = null) {
		return parent::join($fromAlias, $this->prefix($join), $alias, $condition);
	}

	/**
	 * {@inheritdoc}
	 */
	public function innerJoin($fromAlias, $join, $alias, $condition = null) {
		return parent::innerJoin($fromAlias, $this->prefix($join), $alias, $condition);
	}

	/**
	 * {@inheritdoc}
	 */
	public function leftJoin($fromAlias, $join, $alias, $condition = null) {
		return parent::leftJoin($fromAlias, $this->prefix($join), $alias, $condition);
	}

	/**
	 * {@inheritdoc}
	 */
	public function rightJoin($fromAlias, $join, $alias, $condition = null) {
		return parent::rightJoin($fromAlias, $this->prefix($join), $alias, $condition); // TODO: Change the autogenerated stub
	}

	/**
	 * Join metadata table from alias and return joined table alias
	 *
	 * @param string $alias       Main table alias
	 * @param string $guid_column Guid column name in the main table
	 * @param null   $name        Metatadata name
	 * @param string $join_type   JOIN type
	 *
	 * @return string
	 */
	public function joinMetadataTable($alias = '', $guid_column = 'guid', $name = null, $join_type = 'inner') {
		static $index;

		if ($alias) {
			$guid_column = "$alias.$guid_column";
		}

		if (!empty($this->joins[$join_type][self::TABLE_METADATA][$guid_column][$name])) {
			return $this->joins[$join_type][self::TABLE_METADATA][$guid_column][$name];
		}

		$index++;
		$joined_alias = "md{$index}";

		$on = [
			$this->expr()->eq($guid_column, "{$joined_alias}.entity_guid"),
		];

		if (isset($name)) {
			$on[] = $this->expr()->eq("{$joined_alias}.name", $this->param($name, 'string'));
		}

		switch (strtolower($join_type)) {
			default :
			case 'inner' :
				$join_type = 'inner';
				$this->join($alias, self::TABLE_METADATA, $joined_alias, $this->expr()->andX()->addMultiple($on));
				break;

			case 'left' :
				$this->leftJoin($alias, self::TABLE_METADATA, $joined_alias, $this->expr()->andX()->addMultiple($on));
				break;

			case 'right' :
				$this->rightJoin($alias, self::TABLE_METADATA, $joined_alias, $this->expr()->andX()->addMultiple($on));
				break;
		}

		$this->joins[$join_type][self::TABLE_METADATA][$guid_column][$name] = $joined_alias;

		$index++;

		return $joined_alias;
	}

	/**
	 * Join relationship table from alias and return joined table alias
	 *
	 * @param string $alias       Main table alias
	 * @param string $guid_column Guid column name in the main table
	 * @param string $name        Relationship name
	 * @param bool   $inverse     Join on guid_two column
	 * @param string $join_type   JOIN type
	 *
	 * @return string
	 */
	public function joinRelationshipTable($alias = '', $guid_column = 'guid', $name = null, $inverse = false, $join_type = 'inner') {
		static $index;

		if ($alias) {
			$guid_column = "$alias.$guid_column";
		}

		if (!empty($this->joins[$join_type][self::TABLE_RELATIONSHIPS][$guid_column . $inverse][$name])) {
			return $this->joins[$join_type][self::TABLE_RELATIONSHIPS][$guid_column . $inverse][$name];
		}

		$index++;
		$joined_alias = "r{$index}";

		$target_column = $inverse ? "{$joined_alias}.guid_two" : "{$joined_alias}.guid_one";

		$on = [
			$this->expr()->eq($guid_column, $target_column),
		];

		if (isset($name)) {
			$on[] = $this->expr()->eq("{$joined_alias}.relationship", $this->param($name, 'string'));
		}

		switch (strtolower($join_type)) {
			default :
			case 'inner' :
				$join_type = 'inner';
				$this->join($alias, 'entity_relationships', $joined_alias, $this->expr()->andX()->addMultiple($on));
				break;

			case 'left' :
				$this->leftJoin($alias, 'entity_relationships', $joined_alias, $this->expr()->andX()->addMultiple($on));
				break;

			case 'right' :
				$this->rightJoin($alias, 'entity_relationships', $joined_alias, $this->expr()->andX()->addMultiple($on));
				break;
		}

		$this->joins[$join_type][self::TABLE_RELATIONSHIPS][$guid_column . $inverse][$name] = $joined_alias;

		$index++;

		return $joined_alias;
	}
}
